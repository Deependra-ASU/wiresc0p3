#!/usr/bin/env python3

import socket
import sys
import socks

class Exploit():
    def __init__(self, ip, port, name="", debug=False, debug_chaff=False):
        self.ip = ip
        self.port = port
        self.name = "{:30} {}:{} - ".format(name[:30],ip, port)
        self.debug = debug
        self.debug_chaff = debug_chaff
        self.dprint("Launching Exploit")

    def get_flag(self):
        self.connect_to_server()
        self.dprint("Getting Flag")
        self.flag = self.launch_exploit()
        self.sock.close()
        return self.name, self.flag

    def send_chaff(self):
        self.debug = True
        if not self.debug_chaff:
            self.debug = False
        self.connect_to_server()
        self.dprint("Sending Chaff")
        self.flag = self.launch_chaff()
        self.sock.close()        
        return self.flag

 
    def dprint(self, text):
        if self.debug:
            print(self.name + text.strip())


    def connect_to_server(self):
        # socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '127.0.0.1', 4444)
        # self.sock = socks.socksocket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Connect the socket to the port where the server is listening
        server_address = (self.ip, self.port)
        try:
            self.sock.connect(server_address)
            self.dprint('Connected to {} on port {}.'.format(self.ip, self.port))
        except OSError as e:
            self.dprint("ERROR establishing connection to {} on port {}".format(self.ip, self.port))
            sys.exit(1)

    def recv_until(self, endCharacter=None, decode_string='utf-8'):
        try:
            chunks = []
            chunk = b'starter'
            while chunk != b'' and chunk.decode('utf-8') != endCharacter:
                chunk = self.sock.recv(1)
                chunks.append(chunk)
            recv_msg = b''.join(chunks).decode(decode_string).strip()
            self.dprint("Received: " + recv_msg)
            self.write_file(recv_msg)
            return recv_msg
        except OSError as e:
            self.sock.close()
            self.dprint("ERROR receiving data from server: {}".format(e))
            sys.exit(1)

    def send(self, msg, socket):
        self.dprint(msg.strip())
        try:
            socket.send(msg.encode('utf-8'))
        except OSError as e:
            self.dprint("ERROR sending data: {}".format(e))
            sys.exit(1)

    def send_and_close(self, msg, socket):
        self.send(msg, socket)
        socket.close()

    def close(socket):
        socket.close()

    def write_file(self,msg):
        with open('log.txt', 'a') as the_file:
             the_file.write(msg)




